using System;
using System.Threading.Tasks;
using CommandLine;
using System.IO;
using System.Net.Http;

namespace GLThreadGen
{
    public class CommandLineOptions
    {
        public const string KhronosXMLURL = "https://raw.githubusercontent.com/KhronosGroup/OpenGL-Registry/master/xml/gl.xml";
        [Option("noxml", HelpText = "Indicates that XML should not be used.  If this is set, no enums will be generated and the command buffer API will use standard GLenums.")]
        public bool NoXML { get; set; }

        [Option("inputxml", HelpText = "Input XML file to read.  Used to generate type-safe bindings for command buffers.  If this is not provided and the --noxml flag is not set, the XML will be downloaded from GitHub.")]
        public string XMLInputFile { get; set; }

        [Option('i', "input", Required = true, HelpText = "Input file to read.  Must be either a header file generated by GLAD.")]
        public string InputFile { get; set; }
        
        [Option('o', "outdir", Default = "generated", HelpText = "Root directory for generated code")]
        public string OutDir { get; set; }
    }

    class Program
    {
        static void Main(string[] args)
        {
            CommandLineOptions options = null;
            var res = Parser.Default.ParseArguments<CommandLineOptions>(args).WithParsed<CommandLineOptions>(
                opts =>
                {
                    options = opts;
                }
            ).WithNotParsed(
                errors =>
                {
                    foreach (var v in errors)
                    {
                        if (v.Tag == ErrorType.HelpRequestedError)
                        {
                            return;
                        }
                    }

                    Console.Error.WriteLine("Failed to parse command line");
                    foreach (var v in errors)
                    {
                        Console.Error.WriteLine(v);
                    }
                }
            );

            if (options == null) { return; }

            if (!File.Exists(options.InputFile))
            {
                Console.Error.WriteLine($"Input file \"{options.InputFile}\" does not exist.");
                return;
            }

            if (!Directory.Exists(options.OutDir))
            {
                try
                {
                    Directory.CreateDirectory(options.OutDir);
                    Console.WriteLine("Created output directory");
                }
                catch(Exception ex)
                {
                    Console.Error.WriteLine($"Failed to create output directory: {ex.Message}");
                }
            }

            OpenGL_XML_Specification.Registry xmlRegistry = null;
            GLDataRegistry registry = new GLDataRegistry();
            var tracker = new CodegenOverrideTracker(registry);
            
            // Read step
            {
                if (options.InputFile.EndsWith(".h"))
                {
                    Console.WriteLine("Parsing GLAD header from disk...");
                    using (var inStream = new FileStream(options.InputFile, FileMode.Open, FileAccess.Read))
                    {
                        var parser = new GLADHeaderParser(inStream, registry);
                        parser.Parse();
                    }
                }
                else
                {
                    Console.Error.WriteLine($"Input file must be either a Khronos XML document or a header generated by GLAD");
                    return;
                }

                if (!options.NoXML)
                {
                    if (options.XMLInputFile != null)
                    {
                        if (File.Exists(options.XMLInputFile))
                        {
                            Console.WriteLine("Reading Khronos XML from disk...");
                            using (var inStream = new FileStream(options.XMLInputFile, FileMode.Open, FileAccess.Read))
                            {
                                Console.WriteLine($"Parsing XML...");
                                var parser = new KhronosXMLParser(inStream, registry);
                                parser.Parse();
                                xmlRegistry = parser.XMLRegistry;
                            }
                        }
                        else
                        {
                            Console.Error.WriteLine("Input XML file does not exist.  Remove the --inputxml flag to fetch from GitHub or add --noxml to remove type safety.");
                            return;
                        }
                    }

                    using (var client = new HttpClient())
                    {
                        Console.WriteLine($"Downloading {CommandLineOptions.KhronosXMLURL}...");
                        Stream stream = null;
                        Task.Run(async ()=>
                        {
                            stream = await client.GetStreamAsync(CommandLineOptions.KhronosXMLURL);
                        }).Wait();

                        using (stream)
                        {
                            Console.WriteLine($"Parsing XML...");
                            var parser = new KhronosXMLParser(stream, registry);
                            parser.Parse();
                            xmlRegistry = parser.XMLRegistry;
                        }
                    }
                }
            }

            // Post process
            Console.WriteLine($"Read {registry.Functions.Count} functions, post processing...");
            tracker.Initialize(xmlRegistry);

            foreach (var func in registry.Functions.Values)
            {
                var list = tracker.GetOverrideList(func.Name);
                if (list != null)
                {
                    foreach (var ovr in list)
                    {
                        ovr.ModifyFunctionEntry?.Invoke(func);
                    }
                }
            }

            // Write step
            Console.WriteLine("Generating code...");
            var generator = new CodeGenerator(options.OutDir, registry, tracker);
            generator.Generate();
            //generator.OpenDirectory();
            Console.WriteLine("Done");
        }
    }
}
